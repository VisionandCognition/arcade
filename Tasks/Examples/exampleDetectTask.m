

%% condition logic
targetPositions = [
    250 300;
    -200 300;
    0 500;
    0 -500
    ];


%% stimuli
[TaskFolder,~] = fileparts(mfilename('fullpath'));

% fixation point
fp = Circle;
fp.diameter = 5;
fp.position = [0 0];

% target
target = Circle;
target.diameter = 20;
target.alpha = 100;
target.position = targetPositions(TrialData.currentCondition,:);

%% states
acqFix = [];
acqFix.name = 'acqFix';
acqFix.duration = 500;
acqFix.nextState = 'noFix';
acqFix.trackEye = struct(...
    'method', 'circle', ...
    'report', 'enter', ...
    'nextState', 'holdFix', ...
    'center', fp.position, ...
    'radius', 0.8);
acqFix.onEntry = {...
    {@(x) eventmarker(1)}, ...
    {@(x) set(fp, 'visible', true)}, ...
    };

holdFix = [];
holdFix.name = 'holdFix';
holdFix.duration = 500;
holdFix.trackEye = struct(...
    'method', 'circle', ...
    'report', 'leave', ...
    'nextState', 'breakFix', ...
    'center', [0 0], ...
    'radius', 0.8);
acqFix.onEntry = {...
    {@(x) eventmarker(2)}, ...
    };

targetOn = [];
targetOn.name = 'targetOn';
targetOn.duration = 0;
targetOn.onEntry = {...
    {@() eventmarker(3)}, ...
    {@() groupStimuli('start')}, ...
    {@() set(target, 'visible', true)} , ...
    {@() set(fp, 'visible', false)} , ...
    {@() photodiode('on')}, ...
    {@() groupStimuli('end')}, ...
    };
targetOn.nextState = 'waitForResponse';

waitForResponse = [];
waitForResponse.name = 'waitForResponse';
waitForResponse.duration = 1000;
waitForResponse.trackEye = struct(...
    'method', 'circle', ...
    'report', 'enter', ...
    'nextState', 'correct', ...
    'center', target.position, ...
    'radius', 0.8);
waitForResponse.nextState = 'noResponse';

correct = [];
correct.name = 'correct';
correct.duration = 0;
correct.nextState = 'cleanUp';
correct.onEntry = {...
    {@() eventmarker(4)}, ...
    {@() trialerror(1)}, ...
    {@() reward('pulse', 100)}, ...
    };


noFix = [];
noFix.name = 'noFix';
noFix.duration = 0;
noFix.onEntry = {...
    {@() eventmarker(9)}, ...
    {@() trialerror(9)}, ...
    };
noFix.nextState = 'cleanUp';

breakFix = [];
breakFix.duration = 0;
breakFix.onEntry = {...
    {@() eventmarker(5)}, ...
    {@() trialerror(3)}, ...
    };
breakFix.nextState = 'cleanUp';

noResponse = [];
noResponse.duration = 0;
noResponse.onEntry = {...
    {@() eventmarker(6)}, ...
    {@() trialerror(4)}, ...
    };
noResponse.nextState = 'cleanUp';

cleanUp = [];
cleanUp.name = 'cleanUp';
cleanUp.onEntry = {...
    {@() fp.delete()}, ...
    {@() target.delete()}, ...
    };
cleanUp.nextState = 'final';

%% create trial from states
createTrial(acqFix, ... % initial state
    acqFix, holdFix, targetOn, waitForResponse, correct, ...
    noFix, breakFix, noResponse, cleanUp);

