#include <windows.h>
#ifdef DEFINE_GUID
#ifndef FAR
#ifdef _WIN32
#define FAR
#else
#define FAR _far
#endif
#endif
DEFINE_GUID(GUID_DEVINTERFACE_DISK,0x53f56307L,0xb6bf,0x11d0,0x94,0xf2,0x00,0xa0,0xc9,0x1e,0xfb,0x8b);
DEFINE_GUID(GUID_DEVINTERFACE_CDROM,0x53f56308L,0xb6bf,0x11d0,0x94,0xf2,0x00,0xa0,0xc9,0x1e,0xfb,0x8b);
DEFINE_GUID(GUID_DEVINTERFACE_PARTITION,0x53f5630aL,0xb6bf,0x11d0,0x94,0xf2,0x00,0xa0,0xc9,0x1e,0xfb,0x8b);
DEFINE_GUID(GUID_DEVINTERFACE_TAPE,0x53f5630bL,0xb6bf,0x11d0,0x94,0xf2,0x00,0xa0,0xc9,0x1e,0xfb,0x8b);
DEFINE_GUID(GUID_DEVINTERFACE_WRITEONCEDISK,0x53f5630cL,0xb6bf,0x11d0,0x94,0xf2,0x00,0xa0,0xc9,0x1e,0xfb,0x8b);
DEFINE_GUID(GUID_DEVINTERFACE_VOLUME,0x53f5630dL,0xb6bf,0x11d0,0x94,0xf2,0x00,0xa0,0xc9,0x1e,0xfb,0x8b);
DEFINE_GUID(GUID_DEVINTERFACE_MEDIUMCHANGER,0x53f56310L,0xb6bf,0x11d0,0x94,0xf2,0x00,0xa0,0xc9,0x1e,0xfb,0x8b);
DEFINE_GUID(GUID_DEVINTERFACE_FLOPPY,0x53f56311L,0xb6bf,0x11d0,0x94,0xf2,0x00,0xa0,0xc9,0x1e,0xfb,0x8b);
DEFINE_GUID(GUID_DEVINTERFACE_CDCHANGER,0x53f56312L,0xb6bf,0x11d0,0x94,0xf2,0x00,0xa0,0xc9,0x1e,0xfb,0x8b);
DEFINE_GUID(GUID_DEVINTERFACE_STORAGEPORT,0x2accfe60L,0xc130,0x11d2,0xb0,0x82,0x00,0xa0,0xc9,0x1e,0xfb,0x8b);
DEFINE_GUID(GUID_DEVINTERFACE_COMPORT,0x86e0d1e0L,0x8089,0x11d0,0x9c,0xe4,0x08,0x00,0x3e,0x30,0x1f,0x73);
DEFINE_GUID(GUID_DEVINTERFACE_SERENUM_BUS_ENUMERATOR,0x4D36E978L,0xE325,0x11CE,0xBF,0xC1,0x08,0x00,0x2B,0xE1,0x03,0x18);
#define DiskClassGuid GUID_DEVINTERFACE_DISK
#define CdRomClassGuid GUID_DEVINTERFACE_CDROM
#define PartitionClassGuid GUID_DEVINTERFACE_PARTITION
#define TapeClassGuid GUID_DEVINTERFACE_TAPE
#define WriteOnceDiskClassGuid GUID_DEVINTERFACE_WRITEONCEDISK
#define VolumeClassGuid GUID_DEVINTERFACE_VOLUME
#define MediumChangerClassGuid GUID_DEVINTERFACE_MEDIUMCHANGER
#define FloppyClassGuid GUID_DEVINTERFACE_FLOPPY
#define CdChangerClassGuid GUID_DEVINTERFACE_CDCHANGER
#define StoragePortClassGuid GUID_DEVINTERFACE_STORAGEPORT
#define GUID_CLASS_COMPORT GUID_DEVINTERFACE_COMPORT
#define GUID_SERENUM_BUS_ENUMERATOR GUID_DEVINTERFACE_SERENUM_BUS_ENUMERATOR
#endif 
#ifndef _WINIOCTL_
#define _WINIOCTL_
#ifndef _DEVIOCTL_
#define _DEVIOCTL_
#define DEVICE_TYPE DWORD
#define FILE_DEVICE_BEEP 1
#define FILE_DEVICE_CD_ROM 2
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM 3
#define FILE_DEVICE_CONTROLLER 4
#define FILE_DEVICE_DATALINK 5
#define FILE_DEVICE_DFS 6
#define FILE_DEVICE_DISK 7
#define FILE_DEVICE_DISK_FILE_SYSTEM 8
#define FILE_DEVICE_FILE_SYSTEM 9
#define FILE_DEVICE_INPORT_PORT 10
#define FILE_DEVICE_KEYBOARD 11
#define FILE_DEVICE_MAILSLOT 12
#define FILE_DEVICE_MIDI_IN 13
#define FILE_DEVICE_MIDI_OUT 14
#define FILE_DEVICE_MOUSE 15
#define FILE_DEVICE_MULTI_UNC_PROVIDER 16
#define FILE_DEVICE_NAMED_PIPE 17
#define FILE_DEVICE_NETWORK 18
#define FILE_DEVICE_NETWORK_BROWSER 19
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 20
#define FILE_DEVICE_NULL 21
#define FILE_DEVICE_PARALLEL_PORT 22
#define FILE_DEVICE_PHYSICAL_NETCARD 23
#define FILE_DEVICE_PRINTER 24
#define FILE_DEVICE_SCANNER 25
#define FILE_DEVICE_SERIAL_MOUSE_PORT 26
#define FILE_DEVICE_SERIAL_PORT 27
#define FILE_DEVICE_SCREEN 28
#define FILE_DEVICE_SOUND 29
#define FILE_DEVICE_STREAMS 30
#define FILE_DEVICE_TAPE 31
#define FILE_DEVICE_TAPE_FILE_SYSTEM 32
#define FILE_DEVICE_TRANSPORT 33
#define FILE_DEVICE_UNKNOWN 34
#define FILE_DEVICE_VIDEO 35
#define FILE_DEVICE_VIRTUAL_DISK 36
#define FILE_DEVICE_WAVE_IN 37
#define FILE_DEVICE_WAVE_OUT 38
#define FILE_DEVICE_8042_PORT 39
#define FILE_DEVICE_NETWORK_REDIRECTOR 40
#define FILE_DEVICE_BATTERY 41
#define FILE_DEVICE_BUS_EXTENDER 42
#define FILE_DEVICE_MODEM 43
#define FILE_DEVICE_VDM 44
#define FILE_DEVICE_MASS_STORAGE 45
#define FILE_DEVICE_SMB 46
#define FILE_DEVICE_KS 47
#define FILE_DEVICE_CHANGER 48
#define FILE_DEVICE_SMARTCARD 49
#define FILE_DEVICE_ACPI 50
#define FILE_DEVICE_DVD 51
#define FILE_DEVICE_FULLSCREEN_VIDEO 52
#define FILE_DEVICE_DFS_FILE_SYSTEM 53
#define FILE_DEVICE_DFS_VOLUME 54
#define FILE_DEVICE_SERENUM 55
#define FILE_DEVICE_TERMSRV 56
#define FILE_DEVICE_KSEC 57
#define FILE_DEVICE_FIPS 58
#define FILE_DEVICE_INFINIBAND 59
#define CTL_CODE(DeviceType,Function,Method,Access ) (((DeviceType) << 16)|((Access) << 14)|((Function) << 2)|(Method))
#define DEVICE_TYPE_FROM_CTL_CODE(ctrlCode)(((DWORD)(ctrlCode & 0xffff0000)) >> 16)
#define METHOD_BUFFERED 0
#define METHOD_IN_DIRECT 1
#define METHOD_OUT_DIRECT 2
#define METHOD_NEITHER 3
#define METHOD_DIRECT_TO_HARDWARE METHOD_IN_DIRECT
#define METHOD_DIRECT_FROM_HARDWARE METHOD_OUT_DIRECT
#define FILE_ANY_ACCESS 0
#define FILE_SPECIAL_ACCESS (FILE_ANY_ACCESS)
#define FILE_READ_ACCESS (0x0001 ) 
#define FILE_WRITE_ACCESS (0x0002 ) 
#endif 
#ifndef _NTDDSTOR_H_
#define _NTDDSTOR_H_
#define IOCTL_STORAGE_BASE FILE_DEVICE_MASS_STORAGE
#define IOCTL_STORAGE_CHECK_VERIFY CTL_CODE(IOCTL_STORAGE_BASE,0x0200,METHOD_BUFFERED,FILE_READ_ACCESS)
#define IOCTL_STORAGE_CHECK_VERIFY2 CTL_CODE(IOCTL_STORAGE_BASE,0x0200,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_STORAGE_MEDIA_REMOVAL CTL_CODE(IOCTL_STORAGE_BASE,0x0201,METHOD_BUFFERED,FILE_READ_ACCESS)
#define IOCTL_STORAGE_EJECT_MEDIA CTL_CODE(IOCTL_STORAGE_BASE,0x0202,METHOD_BUFFERED,FILE_READ_ACCESS)
#define IOCTL_STORAGE_LOAD_MEDIA CTL_CODE(IOCTL_STORAGE_BASE,0x0203,METHOD_BUFFERED,FILE_READ_ACCESS)
#define IOCTL_STORAGE_LOAD_MEDIA2 CTL_CODE(IOCTL_STORAGE_BASE,0x0203,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_STORAGE_RESERVE CTL_CODE(IOCTL_STORAGE_BASE,0x0204,METHOD_BUFFERED,FILE_READ_ACCESS)
#define IOCTL_STORAGE_RELEASE CTL_CODE(IOCTL_STORAGE_BASE,0x0205,METHOD_BUFFERED,FILE_READ_ACCESS)
#define IOCTL_STORAGE_FIND_NEW_DEVICES CTL_CODE(IOCTL_STORAGE_BASE,0x0206,METHOD_BUFFERED,FILE_READ_ACCESS)
#define IOCTL_STORAGE_EJECTION_CONTROL CTL_CODE(IOCTL_STORAGE_BASE,0x0250,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_STORAGE_MCN_CONTROL CTL_CODE(IOCTL_STORAGE_BASE,0x0251,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_STORAGE_GET_MEDIA_TYPES CTL_CODE(IOCTL_STORAGE_BASE,0x0300,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_STORAGE_GET_MEDIA_TYPES_EX CTL_CODE(IOCTL_STORAGE_BASE,0x0301,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER CTL_CODE(IOCTL_STORAGE_BASE,0x0304,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_STORAGE_GET_HOTPLUG_INFO CTL_CODE(IOCTL_STORAGE_BASE,0x0305,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_STORAGE_SET_HOTPLUG_INFO CTL_CODE(IOCTL_STORAGE_BASE,0x0306,METHOD_BUFFERED,FILE_READ_ACCESS|FILE_WRITE_ACCESS)
#define IOCTL_STORAGE_RESET_BUS CTL_CODE(IOCTL_STORAGE_BASE,0x0400,METHOD_BUFFERED,FILE_READ_ACCESS)
#define IOCTL_STORAGE_RESET_DEVICE CTL_CODE(IOCTL_STORAGE_BASE,0x0401,METHOD_BUFFERED,FILE_READ_ACCESS)
#define IOCTL_STORAGE_BREAK_RESERVATION CTL_CODE(IOCTL_STORAGE_BASE,0x0405,METHOD_BUFFERED,FILE_READ_ACCESS)
#define IOCTL_STORAGE_GET_DEVICE_NUMBER CTL_CODE(IOCTL_STORAGE_BASE,0x0420,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_STORAGE_PREDICT_FAILURE CTL_CODE(IOCTL_STORAGE_BASE,0x0440,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define OBSOLETE_IOCTL_STORAGE_RESET_BUS CTL_CODE(IOCTL_STORAGE_BASE,0x0400,METHOD_BUFFERED,FILE_READ_ACCESS|FILE_WRITE_ACCESS)
#define OBSOLETE_IOCTL_STORAGE_RESET_DEVICE CTL_CODE(IOCTL_STORAGE_BASE,0x0401,METHOD_BUFFERED,FILE_READ_ACCESS|FILE_WRITE_ACCESS)
typedef struct _STORAGE_HOTPLUG_INFO {
	DWORD Size; 
	BOOLEAN MediaRemovable; 
	BOOLEAN MediaHotplug; 
	BOOLEAN DeviceHotplug; 
	BOOLEAN WriteCacheEnableOverride; 
} STORAGE_HOTPLUG_INFO,*PSTORAGE_HOTPLUG_INFO;
typedef struct _STORAGE_DEVICE_NUMBER {
	DEVICE_TYPE DeviceType;
	DWORD DeviceNumber;
	DWORD PartitionNumber;
} STORAGE_DEVICE_NUMBER,*PSTORAGE_DEVICE_NUMBER;
typedef struct _STORAGE_BUS_RESET_REQUEST {
	BYTE PathId;
} STORAGE_BUS_RESET_REQUEST,*PSTORAGE_BUS_RESET_REQUEST;
typedef struct STORAGE_BREAK_RESERVATION_REQUEST {
		DWORD Length;
		BYTE _unused;
	BYTE PathId;
	BYTE TargetId;
	BYTE Lun;
} STORAGE_BREAK_RESERVATION_REQUEST,*PSTORAGE_BREAK_RESERVATION_REQUEST;
typedef struct _PREVENT_MEDIA_REMOVAL {
	BOOLEAN PreventMediaRemoval;
} PREVENT_MEDIA_REMOVAL,*PPREVENT_MEDIA_REMOVAL;
typedef struct _CLASS_MEDIA_CHANGE_CONTEXT {
		DWORD MediaChangeCount;
		DWORD NewState; 
} CLASS_MEDIA_CHANGE_CONTEXT,*PCLASS_MEDIA_CHANGE_CONTEXT;
typedef struct _TAPE_STATISTICS {
	DWORD Version;
	DWORD Flags;
	LARGE_INTEGER RecoveredWrites;
	LARGE_INTEGER UnrecoveredWrites;
	LARGE_INTEGER RecoveredReads;
	LARGE_INTEGER UnrecoveredReads;
	BYTE CompressionRatioReads;
	BYTE CompressionRatioWrites;
} TAPE_STATISTICS,*PTAPE_STATISTICS;
#define RECOVERED_WRITES_VALID 1
#define UNRECOVERED_WRITES_VALID 2
#define RECOVERED_READS_VALID 4
#define UNRECOVERED_READS_VALID 8
#define WRITE_COMPRESSION_INFO_VALID 16
#define READ_COMPRESSION_INFO_VALID 32
typedef struct _TAPE_GET_STATISTICS {
	DWORD Operation;
} TAPE_GET_STATISTICS,*PTAPE_GET_STATISTICS;
#define TAPE_RETURN_STATISTICS 0L
#define TAPE_RETURN_ENV_INFO 1L
#define TAPE_RESET_STATISTICS 2L
typedef enum _STORAGE_MEDIA_TYPE {
	DDS_4mm=0x20,MiniQic,Travan,QIC,MP_8mm,AME_8mm,AIT1_8mm,DLT,NCTP,IBM_3480,IBM_3490E,
	IBM_Magstar_3590,IBM_Magstar_MP,STK_DATA_D3,SONY_DTF,DV_6mm,DMI,SONY_D2,
	CLEANER_CARTRIDGE,CD_ROM,CD_R,CD_RW,DVD_ROM,DVD_R,DVD_RW,MO_3_RW,MO_5_WO,MO_5_RW,
	MO_5_LIMDOW,PC_5_WO,PC_5_RW,PD_5_RW,ABL_5_WO,PINNACLE_APEX_5_RW,SONY_12_WO,
	PHILIPS_12_WO,HITACHI_12_WO,CYGNET_12_WO,KODAK_14_WO,MO_NFR_525,NIKON_12_RW,
	IOMEGA_ZIP,IOMEGA_JAZ,SYQUEST_EZ135,SYQUEST_EZFLYER,SYQUEST_SYJET,AVATAR_F2,MP2_8mm,DST_S,
	DST_M,DST_L,VXATape_1,VXATape_2,STK_9840,LTO_Ultrium,LTO_Accelis,DVD_RAM,AIT_8mm,ADR_1,ADR_2,STK_9940,SAIT 
} STORAGE_MEDIA_TYPE,*PSTORAGE_MEDIA_TYPE;
#define MEDIA_ERASEABLE 1
#define MEDIA_WRITE_ONCE 2
#define MEDIA_READ_ONLY 4
#define MEDIA_READ_WRITE 8
#define MEDIA_WRITE_PROTECTED 256
#define MEDIA_CURRENTLY_MOUNTED 0x80000000
typedef enum _STORAGE_BUS_TYPE {
	BusTypeUnknown=0x00,BusTypeScsi,BusTypeAtapi,BusTypeAta,BusType1394,BusTypeSsa,BusTypeFibre,
	BusTypeUsb,BusTypeRAID,BusTypeMaxReserved=0x7F
} STORAGE_BUS_TYPE,*PSTORAGE_BUS_TYPE;
typedef struct _DEVICE_MEDIA_INFO {
	union {
		struct {
			LARGE_INTEGER Cylinders;
			STORAGE_MEDIA_TYPE MediaType;
			DWORD TracksPerCylinder;
			DWORD SectorsPerTrack;
			DWORD BytesPerSector;
			DWORD NumberMediaSides;
			DWORD MediaCharacteristics; 
		} DiskInfo;
		struct {
			LARGE_INTEGER Cylinders;
			STORAGE_MEDIA_TYPE MediaType;
			DWORD TracksPerCylinder;
			DWORD SectorsPerTrack;
			DWORD BytesPerSector;
			DWORD NumberMediaSides;
			DWORD MediaCharacteristics; 
		} RemovableDiskInfo;
		struct {
			STORAGE_MEDIA_TYPE MediaType;
			DWORD MediaCharacteristics; 
			DWORD CurrentBlockSize;
			STORAGE_BUS_TYPE BusType;
			union {
				struct {
				 BYTE MediumType;
				 BYTE DensityCode;
				} ScsiInformation;
			} BusSpecificData;
		} TapeInfo;
	} DeviceSpecific;
} DEVICE_MEDIA_INFO,*PDEVICE_MEDIA_INFO;
typedef struct _GET_MEDIA_TYPES {
	DWORD DeviceType; 
	DWORD MediaInfoCount;
	DEVICE_MEDIA_INFO MediaInfo[1];
} GET_MEDIA_TYPES,*PGET_MEDIA_TYPES;
typedef struct _STORAGE_PREDICT_FAILURE {
	DWORD PredictFailure;
	BYTE VendorSpecific[512];
} STORAGE_PREDICT_FAILURE,*PSTORAGE_PREDICT_FAILURE;
#endif 
#define IOCTL_DISK_BASE FILE_DEVICE_DISK
#define IOCTL_DISK_GET_DRIVE_GEOMETRY CTL_CODE(IOCTL_DISK_BASE,0x0000,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_DISK_GET_PARTITION_INFO CTL_CODE(IOCTL_DISK_BASE,0x0001,METHOD_BUFFERED,FILE_READ_ACCESS)
#define IOCTL_DISK_SET_PARTITION_INFO CTL_CODE(IOCTL_DISK_BASE,0x0002,METHOD_BUFFERED,FILE_READ_ACCESS|FILE_WRITE_ACCESS)
#define IOCTL_DISK_GET_DRIVE_LAYOUT CTL_CODE(IOCTL_DISK_BASE,0x0003,METHOD_BUFFERED,FILE_READ_ACCESS)
#define IOCTL_DISK_SET_DRIVE_LAYOUT CTL_CODE(IOCTL_DISK_BASE,0x0004,METHOD_BUFFERED,FILE_READ_ACCESS|FILE_WRITE_ACCESS)
#define IOCTL_DISK_VERIFY CTL_CODE(IOCTL_DISK_BASE,0x0005,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_DISK_FORMAT_TRACKS CTL_CODE(IOCTL_DISK_BASE,0x0006,METHOD_BUFFERED,FILE_READ_ACCESS|FILE_WRITE_ACCESS)
#define IOCTL_DISK_REASSIGN_BLOCKS CTL_CODE(IOCTL_DISK_BASE,0x0007,METHOD_BUFFERED,FILE_READ_ACCESS|FILE_WRITE_ACCESS)
#define IOCTL_DISK_PERFORMANCE CTL_CODE(IOCTL_DISK_BASE,0x0008,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_DISK_IS_WRITABLE CTL_CODE(IOCTL_DISK_BASE,0x0009,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_DISK_LOGGING CTL_CODE(IOCTL_DISK_BASE,0x000a,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_DISK_FORMAT_TRACKS_EX CTL_CODE(IOCTL_DISK_BASE,0x000b,METHOD_BUFFERED,FILE_READ_ACCESS|FILE_WRITE_ACCESS)
#define IOCTL_DISK_HISTOGRAM_STRUCTURE CTL_CODE(IOCTL_DISK_BASE,0x000c,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_DISK_HISTOGRAM_DATA CTL_CODE(IOCTL_DISK_BASE,0x000d,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_DISK_HISTOGRAM_RESET CTL_CODE(IOCTL_DISK_BASE,0x000e,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_DISK_REQUEST_STRUCTURE CTL_CODE(IOCTL_DISK_BASE,0x000f,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_DISK_REQUEST_DATA CTL_CODE(IOCTL_DISK_BASE,0x0010,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_DISK_PERFORMANCE_OFF CTL_CODE(IOCTL_DISK_BASE,0x0018,METHOD_BUFFERED,FILE_ANY_ACCESS)
#if(_WIN32_WINNT >=0x0400)
#define IOCTL_DISK_CONTROLLER_NUMBER CTL_CODE(IOCTL_DISK_BASE,0x0011,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define SMART_GET_VERSION CTL_CODE(IOCTL_DISK_BASE,0x0020,METHOD_BUFFERED,FILE_READ_ACCESS)
#define SMART_SEND_DRIVE_COMMAND CTL_CODE(IOCTL_DISK_BASE,0x0021,METHOD_BUFFERED,FILE_READ_ACCESS|FILE_WRITE_ACCESS)
#define SMART_RCV_DRIVE_DATA CTL_CODE(IOCTL_DISK_BASE,0x0022,METHOD_BUFFERED,FILE_READ_ACCESS|FILE_WRITE_ACCESS)
#endif 
#if (_WIN32_WINNT >=0x500)
#define IOCTL_DISK_GET_PARTITION_INFO_EX CTL_CODE(IOCTL_DISK_BASE,0x0012,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_DISK_SET_PARTITION_INFO_EX CTL_CODE(IOCTL_DISK_BASE,0x0013,METHOD_BUFFERED,FILE_READ_ACCESS|FILE_WRITE_ACCESS)
#define IOCTL_DISK_GET_DRIVE_LAYOUT_EX CTL_CODE(IOCTL_DISK_BASE,0x0014,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_DISK_SET_DRIVE_LAYOUT_EX CTL_CODE(IOCTL_DISK_BASE,0x0015,METHOD_BUFFERED,FILE_READ_ACCESS|FILE_WRITE_ACCESS)
#define IOCTL_DISK_CREATE_DISK CTL_CODE(IOCTL_DISK_BASE,0x0016,METHOD_BUFFERED,FILE_READ_ACCESS|FILE_WRITE_ACCESS)
#define IOCTL_DISK_GET_LENGTH_INFO CTL_CODE(IOCTL_DISK_BASE,0x0017,METHOD_BUFFERED,FILE_READ_ACCESS)
#define IOCTL_DISK_GET_DRIVE_GEOMETRY_EX CTL_CODE(IOCTL_DISK_BASE,0x0028,METHOD_BUFFERED,FILE_ANY_ACCESS)
#endif 
#if(_WIN32_WINNT >=0x0500)
#define IOCTL_DISK_UPDATE_DRIVE_SIZE CTL_CODE(IOCTL_DISK_BASE,0x0032,METHOD_BUFFERED,FILE_READ_ACCESS|FILE_WRITE_ACCESS)
#define IOCTL_DISK_GROW_PARTITION CTL_CODE(IOCTL_DISK_BASE,0x0034,METHOD_BUFFERED,FILE_READ_ACCESS|FILE_WRITE_ACCESS)
#define IOCTL_DISK_GET_CACHE_INFORMATION CTL_CODE(IOCTL_DISK_BASE,0x0035,METHOD_BUFFERED,FILE_READ_ACCESS)
#define IOCTL_DISK_SET_CACHE_INFORMATION CTL_CODE(IOCTL_DISK_BASE,0x0036,METHOD_BUFFERED,FILE_READ_ACCESS|FILE_WRITE_ACCESS)
#define OBSOLETE_DISK_GET_WRITE_CACHE_STATE CTL_CODE(IOCTL_DISK_BASE,0x0037,METHOD_BUFFERED,FILE_READ_ACCESS)
#define IOCTL_DISK_DELETE_DRIVE_LAYOUT CTL_CODE(IOCTL_DISK_BASE,0x0040,METHOD_BUFFERED,FILE_READ_ACCESS|FILE_WRITE_ACCESS)
#define IOCTL_DISK_UPDATE_PROPERTIES CTL_CODE(IOCTL_DISK_BASE,0x0050,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_DISK_FORMAT_DRIVE CTL_CODE(IOCTL_DISK_BASE,0x00f3,METHOD_BUFFERED,FILE_READ_ACCESS|FILE_WRITE_ACCESS)
#define IOCTL_DISK_SENSE_DEVICE CTL_CODE(IOCTL_DISK_BASE,0x00f8,METHOD_BUFFERED,FILE_ANY_ACCESS)
#endif 
#define IOCTL_DISK_CHECK_VERIFY CTL_CODE(IOCTL_DISK_BASE,0x0200,METHOD_BUFFERED,FILE_READ_ACCESS)
#define IOCTL_DISK_MEDIA_REMOVAL CTL_CODE(IOCTL_DISK_BASE,0x0201,METHOD_BUFFERED,FILE_READ_ACCESS)
#define IOCTL_DISK_EJECT_MEDIA CTL_CODE(IOCTL_DISK_BASE,0x0202,METHOD_BUFFERED,FILE_READ_ACCESS)
#define IOCTL_DISK_LOAD_MEDIA CTL_CODE(IOCTL_DISK_BASE,0x0203,METHOD_BUFFERED,FILE_READ_ACCESS)
#define IOCTL_DISK_RESERVE CTL_CODE(IOCTL_DISK_BASE,0x0204,METHOD_BUFFERED,FILE_READ_ACCESS)
#define IOCTL_DISK_RELEASE CTL_CODE(IOCTL_DISK_BASE,0x0205,METHOD_BUFFERED,FILE_READ_ACCESS)
#define IOCTL_DISK_FIND_NEW_DEVICES CTL_CODE(IOCTL_DISK_BASE,0x0206,METHOD_BUFFERED,FILE_READ_ACCESS)
#define IOCTL_DISK_GET_MEDIA_TYPES CTL_CODE(IOCTL_DISK_BASE,0x0300,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define PARTITION_ENTRY_UNUSED 0 
#define PARTITION_FAT_12 1 
#define PARTITION_XENIX_1 2 
#define PARTITION_XENIX_2 3 
#define PARTITION_FAT_16 4 
#define PARTITION_EXTENDED 5 
#define PARTITION_HUGE 6 
#define PARTITION_IFS 7 
#define PARTITION_OS2BOOTMGR 10 
#define PARTITION_FAT32 11 
#define PARTITION_FAT32_XINT13 12 
#define PARTITION_XINT13 14 
#define PARTITION_XINT13_EXTENDED 15 
#define PARTITION_PREP 65 
#define PARTITION_LDM 66 
#define PARTITION_UNIX 99 
#define VALID_NTFT 192 
#define PARTITION_NTFT 128 
#define IsRecognizedPartition(PartitionType ) (((PartitionType & PARTITION_NTFT) && ((PartitionType & ~0xC0)==PARTITION_FAT_12))\
	||((PartitionType & PARTITION_NTFT) && ((PartitionType & ~0xC0)==PARTITION_IFS))||((PartitionType & PARTITION_NTFT) \
	&& ((PartitionType & ~0xC0)==PARTITION_HUGE))||((PartitionType & PARTITION_NTFT) && ((PartitionType & ~0xC0)==PARTITION_FAT32))\
	||((PartitionType & PARTITION_NTFT) && ((PartitionType & ~0xC0)==PARTITION_FAT32_XINT13))||((PartitionType & PARTITION_NTFT)\
	&& ((PartitionType & ~0xC0)==PARTITION_XINT13))||((PartitionType)==PARTITION_FAT_12)||((PartitionType)==PARTITION_FAT_16)\
	||((PartitionType)==PARTITION_IFS)||((PartitionType)==PARTITION_HUGE)||((PartitionType)==PARTITION_FAT32)\
	||((PartitionType)==PARTITION_FAT32_XINT13)||((PartitionType)==PARTITION_XINT13) )
#define IsContainerPartition(PartitionType )((PartitionType==PARTITION_EXTENDED)||(PartitionType==PARTITION_XINT13_EXTENDED))
#define IsFTPartition(PartitionType )(((PartitionType)&PARTITION_NTFT) && IsRecognizedPartition(PartitionType))
typedef enum _MEDIA_TYPE {
	Unknown,F5_1Pt2_512,F3_1Pt44_512,F3_2Pt88_512,F3_20Pt8_512,F3_720_512,F5_360_512,F5_320_512,F5_320_1024,
	F5_180_512,F5_160_512,RemovableMedia,FixedMedia,F3_120M_512,F3_640_512,F5_640_512,F5_720_512,F3_1Pt2_512,
	F3_1Pt23_1024,F5_1Pt23_1024,F3_128Mb_512,
	F3_230Mb_512,F8_256_128,F3_200Mb_512,F3_240M_512,F3_32M_512 
} MEDIA_TYPE,*PMEDIA_TYPE;
typedef struct _FORMAT_PARAMETERS {
 MEDIA_TYPE MediaType;
 DWORD StartCylinderNumber;
 DWORD EndCylinderNumber;
 DWORD StartHeadNumber;
 DWORD EndHeadNumber;
} FORMAT_PARAMETERS,*PFORMAT_PARAMETERS;
typedef WORD BAD_TRACK_NUMBER;
typedef WORD *PBAD_TRACK_NUMBER;
typedef struct _FORMAT_EX_PARAMETERS {
 MEDIA_TYPE MediaType;
 DWORD StartCylinderNumber;
 DWORD EndCylinderNumber;
 DWORD StartHeadNumber;
 DWORD EndHeadNumber;
 WORD FormatGapLength;
 WORD SectorsPerTrack;
 WORD SectorNumber[1];
} FORMAT_EX_PARAMETERS,*PFORMAT_EX_PARAMETERS;
typedef struct _DISK_GEOMETRY {
	LARGE_INTEGER Cylinders;
	MEDIA_TYPE MediaType;
	DWORD TracksPerCylinder;
	DWORD SectorsPerTrack;
	DWORD BytesPerSector;
} DISK_GEOMETRY,*PDISK_GEOMETRY;
#define WMI_DISK_GEOMETRY_GUID { 0x25007f51,0x57c2,0x11d1,{ 0xa5,0x28,0x0,0xa0,0xc9,0x6,0x29,0x10 } }
typedef struct _PARTITION_INFORMATION {
	LARGE_INTEGER StartingOffset;
	LARGE_INTEGER PartitionLength;
	DWORD HiddenSectors;
	DWORD PartitionNumber;
	BYTE PartitionType;
	BOOLEAN BootIndicator;
	BOOLEAN RecognizedPartition;
	BOOLEAN RewritePartition;
} PARTITION_INFORMATION,*PPARTITION_INFORMATION;
typedef struct _SET_PARTITION_INFORMATION {
	BYTE PartitionType;
} SET_PARTITION_INFORMATION,*PSET_PARTITION_INFORMATION;
typedef struct _DRIVE_LAYOUT_INFORMATION {
	DWORD PartitionCount;
	DWORD Signature;
	PARTITION_INFORMATION PartitionEntry[1];
} DRIVE_LAYOUT_INFORMATION,*PDRIVE_LAYOUT_INFORMATION;
typedef struct _VERIFY_INFORMATION {
	LARGE_INTEGER StartingOffset;
	DWORD Length;
} VERIFY_INFORMATION,*PVERIFY_INFORMATION;
typedef struct _REASSIGN_BLOCKS {
	WORD Reserved;
	WORD Count;
	DWORD BlockNumber[1];
} REASSIGN_BLOCKS,*PREASSIGN_BLOCKS;
#if(_WIN32_WINNT >=0x500)
typedef enum _PARTITION_STYLE {
	PARTITION_STYLE_MBR,PARTITION_STYLE_GPT,PARTITION_STYLE_RAW
} PARTITION_STYLE;
typedef struct _PARTITION_INFORMATION_GPT {
	GUID PartitionType; 
	GUID PartitionId; 
	DWORD64 Attributes; 
	WCHAR Name [36]; 
} PARTITION_INFORMATION_GPT,*PPARTITION_INFORMATION_GPT;
#define GPT_ATTRIBUTE_PLATFORM_REQUIRED 1
#define GPT_BASIC_DATA_ATTRIBUTE_NO_DRIVE_LETTER 0xffffffff
#define GPT_BASIC_DATA_ATTRIBUTE_HIDDEN 0
#define GPT_BASIC_DATA_ATTRIBUTE_READ_ONLY 0
typedef struct _PARTITION_INFORMATION_MBR {
	BYTE PartitionType;
	BOOLEAN BootIndicator;
	BOOLEAN RecognizedPartition;
	DWORD HiddenSectors;
} PARTITION_INFORMATION_MBR,*PPARTITION_INFORMATION_MBR;
typedef SET_PARTITION_INFORMATION SET_PARTITION_INFORMATION_MBR;
typedef PARTITION_INFORMATION_GPT SET_PARTITION_INFORMATION_GPT;
typedef struct _SET_PARTITION_INFORMATION_EX {
	PARTITION_STYLE PartitionStyle;
	union {
		SET_PARTITION_INFORMATION_MBR Mbr;
		SET_PARTITION_INFORMATION_GPT Gpt;
	};
} SET_PARTITION_INFORMATION_EX,*PSET_PARTITION_INFORMATION_EX;
typedef struct _CREATE_DISK_GPT {
	GUID DiskId; 
	DWORD MaxPartitionCount; 
} CREATE_DISK_GPT,*PCREATE_DISK_GPT;
typedef struct _CREATE_DISK_MBR {
	DWORD Signature;
} CREATE_DISK_MBR,*PCREATE_DISK_MBR;
typedef struct _CREATE_DISK {
	PARTITION_STYLE PartitionStyle;
	union {
		CREATE_DISK_MBR Mbr;
		CREATE_DISK_GPT Gpt;
	};
} CREATE_DISK,*PCREATE_DISK;
typedef struct _GET_LENGTH_INFORMATION {
	LARGE_INTEGER Length;
} GET_LENGTH_INFORMATION,*PGET_LENGTH_INFORMATION;
typedef struct _PARTITION_INFORMATION_EX {
	PARTITION_STYLE PartitionStyle;
	LARGE_INTEGER StartingOffset;
	LARGE_INTEGER PartitionLength;
	DWORD PartitionNumber;
	BOOLEAN RewritePartition;
	union {
		PARTITION_INFORMATION_MBR Mbr;
		PARTITION_INFORMATION_GPT Gpt;
	};
} PARTITION_INFORMATION_EX,*PPARTITION_INFORMATION_EX;
typedef struct _DRIVE_LAYOUT_INFORMATION_GPT {
	GUID DiskId;
	LARGE_INTEGER StartingUsableOffset;
	LARGE_INTEGER UsableLength;
	DWORD MaxPartitionCount;
} DRIVE_LAYOUT_INFORMATION_GPT,*PDRIVE_LAYOUT_INFORMATION_GPT;
typedef struct _DRIVE_LAYOUT_INFORMATION_MBR {
	DWORD Signature;
} DRIVE_LAYOUT_INFORMATION_MBR,*PDRIVE_LAYOUT_INFORMATION_MBR;
typedef struct _DRIVE_LAYOUT_INFORMATION_EX {
	DWORD PartitionStyle;
	DWORD PartitionCount;
	union {
		DRIVE_LAYOUT_INFORMATION_MBR Mbr;
		DRIVE_LAYOUT_INFORMATION_GPT Gpt;
	};
	PARTITION_INFORMATION_EX PartitionEntry[1];
} DRIVE_LAYOUT_INFORMATION_EX,*PDRIVE_LAYOUT_INFORMATION_EX;
#endif 
#if(_WIN32_WINNT >=0x0500)
typedef enum _DETECTION_TYPE {
		DetectNone,DetectInt13,DetectExInt13
} DETECTION_TYPE;
typedef struct _DISK_INT13_INFO {
		WORD DriveSelect;
		DWORD MaxCylinders;
		WORD SectorsPerTrack;
		WORD MaxHeads;
		WORD NumberDrives;
} DISK_INT13_INFO,*PDISK_INT13_INFO;
typedef struct _DISK_EX_INT13_INFO {
		WORD ExBufferSize;
		WORD ExFlags;
		DWORD ExCylinders;
		DWORD ExHeads;
		DWORD ExSectorsPerTrack;
		DWORD64 ExSectorsPerDrive;
		WORD ExSectorSize;
		WORD ExReserved;
} DISK_EX_INT13_INFO,*PDISK_EX_INT13_INFO;
typedef struct _DISK_DETECTION_INFO {
		DWORD SizeOfDetectInfo;
		DETECTION_TYPE DetectionType;
		union {
				struct {
				 DISK_INT13_INFO Int13;
				 DISK_EX_INT13_INFO ExInt13; 
				};
		};
} DISK_DETECTION_INFO,*PDISK_DETECTION_INFO;
typedef struct _DISK_PARTITION_INFO {
		DWORD SizeOfPartitionInfo;
		PARTITION_STYLE PartitionStyle; 
		union {
				struct { 
				 DWORD Signature; 
				 DWORD CheckSum; 
				} Mbr;
				struct { 
				 GUID DiskId;
				} Gpt;
		};
} DISK_PARTITION_INFO,*PDISK_PARTITION_INFO;
#define DiskGeometryGetPartition(Geometry) ((PDISK_PARTITION_INFO)((Geometry)->Data))
#define DiskGeometryGetDetect(Geometry) ((PDISK_DETECTION_INFO)(((DWORD_PTR)DiskGeometryGetPartition(Geometry)+ \
	DiskGeometryGetPartition(Geometry)->SizeOfPartitionInfo)))
typedef struct _DISK_GEOMETRY_EX {
		DISK_GEOMETRY Geometry; 
		LARGE_INTEGER DiskSize; 
		BYTE Data[1]; 
} DISK_GEOMETRY_EX,*PDISK_GEOMETRY_EX;
#endif 
#if(_WIN32_WINNT >=0x0400)
typedef struct _DISK_CONTROLLER_NUMBER {
	DWORD ControllerNumber;
	DWORD DiskNumber;
} DISK_CONTROLLER_NUMBER,*PDISK_CONTROLLER_NUMBER;
#endif 
#if(_WIN32_WINNT >=0x0500)
typedef enum {
	EqualPriority,KeepPrefetchedData,KeepReadData
} DISK_CACHE_RETENTION_PRIORITY;
typedef struct _DISK_CACHE_INFORMATION {
	BOOLEAN ParametersSavable;
	BOOLEAN ReadCacheEnabled;
	BOOLEAN WriteCacheEnabled;
	DISK_CACHE_RETENTION_PRIORITY ReadRetentionPriority;
	DISK_CACHE_RETENTION_PRIORITY WriteRetentionPriority;
	WORD DisablePrefetchTransferLength;
	BOOLEAN PrefetchScalar;
	union {
		struct {
			WORD Minimum;
			WORD Maximum;
			WORD MaximumBlocks;
		} ScalarPrefetch;
		struct {
			WORD Minimum;
			WORD Maximum;
		} BlockPrefetch;
	};
} DISK_CACHE_INFORMATION,*PDISK_CACHE_INFORMATION;
typedef struct _DISK_GROW_PARTITION {
	DWORD PartitionNumber;
	LARGE_INTEGER BytesToGrow;
} DISK_GROW_PARTITION,*PDISK_GROW_PARTITION;
#endif 
#define HIST_NO_OF_BUCKETS 24
typedef struct _HISTOGRAM_BUCKET {
	DWORD Reads;
	DWORD Writes;
} HISTOGRAM_BUCKET,*PHISTOGRAM_BUCKET;
#define HISTOGRAM_BUCKET_SIZE sizeof(HISTOGRAM_BUCKET)
typedef struct _DISK_HISTOGRAM {
	LARGE_INTEGER DiskSize;
	LARGE_INTEGER Start;
	LARGE_INTEGER End;
	LARGE_INTEGER Average;
	LARGE_INTEGER AverageRead;
	LARGE_INTEGER AverageWrite;
	DWORD Granularity;
	DWORD Size;
	DWORD ReadCount;
	DWORD WriteCount;
	PHISTOGRAM_BUCKET Histogram;
} DISK_HISTOGRAM,*PDISK_HISTOGRAM;
#define DISK_HISTOGRAM_SIZE sizeof(DISK_HISTOGRAM)
typedef struct _DISK_PERFORMANCE {
		LARGE_INTEGER BytesRead;
		LARGE_INTEGER BytesWritten;
		LARGE_INTEGER ReadTime;
		LARGE_INTEGER WriteTime;
		LARGE_INTEGER IdleTime;
		DWORD ReadCount;
		DWORD WriteCount;
		DWORD QueueDepth;
		DWORD SplitCount;
		LARGE_INTEGER QueryTime;
		DWORD StorageDeviceNumber;
		WCHAR StorageManagerName[8];
} DISK_PERFORMANCE,*PDISK_PERFORMANCE;
typedef struct _DISK_RECORD {
 LARGE_INTEGER ByteOffset;
 LARGE_INTEGER StartTime;
 LARGE_INTEGER EndTime;
 PVOID VirtualAddress;
 DWORD NumberOfBytes;
 BYTE DeviceNumber;
 BOOLEAN ReadRequest;
} DISK_RECORD,*PDISK_RECORD;
typedef struct _DISK_LOGGING {
	BYTE Function;
	PVOID BufferAddress;
	DWORD BufferSize;
} DISK_LOGGING,*PDISK_LOGGING;
#define DISK_LOGGING_START 0
#define DISK_LOGGING_STOP 1
#define DISK_LOGGING_DUMP 2
#define DISK_BINNING 3
typedef enum _BIN_TYPES {
	RequestSize,RequestLocation
} BIN_TYPES;
typedef struct _BIN_RANGE {
	LARGE_INTEGER StartValue;
	LARGE_INTEGER Length;
} BIN_RANGE,*PBIN_RANGE;
typedef struct _PERF_BIN {
	DWORD NumberOfBins;
	DWORD TypeOfBin;
	BIN_RANGE BinsRanges[1];
} PERF_BIN,*PPERF_BIN ;
typedef struct _BIN_COUNT {
	BIN_RANGE BinRange;
	DWORD BinCount;
} BIN_COUNT,*PBIN_COUNT;
typedef struct _BIN_RESULTS {
	DWORD NumberOfBins;
	BIN_COUNT BinCounts[1];
} BIN_RESULTS,*PBIN_RESULTS;
#if(_WIN32_WINNT >=0x0400)
#include <pshpack1.h>
typedef struct _GETVERSIONINPARAMS {
		BYTE bVersion; 
		BYTE bRevision; 
		BYTE bReserved; 
		BYTE bIDEDeviceMap; 
		DWORD fCapabilities; 
		DWORD dwReserved[4]; 
} GETVERSIONINPARAMS,*PGETVERSIONINPARAMS,*LPGETVERSIONINPARAMS;
#include <poppack.h>
#define CAP_ATA_ID_CMD 1 
#define CAP_ATAPI_ID_CMD 2 
#define CAP_SMART_CMD 4 
#include <pshpack1.h>
typedef struct _IDEREGS {
		BYTE bFeaturesReg; 
		BYTE bSectorCountReg; 
		BYTE bSectorNumberReg; 
		BYTE bCylLowReg; 
		BYTE bCylHighReg; 
		BYTE bDriveHeadReg; 
		BYTE bCommandReg; 
		BYTE bReserved; 
} IDEREGS,*PIDEREGS,*LPIDEREGS;
#include <poppack.h>
#define ATAPI_ID_CMD 161 
#define ID_CMD 236 
#define SMART_CMD 176 
#define SMART_CYL_LOW 79
#define SMART_CYL_HI 194
#include <pshpack1.h>
typedef struct _SENDCMDINPARAMS {
		DWORD cBufferSize; 
		IDEREGS irDriveRegs; 
		BYTE bDriveNumber; 
		BYTE bReserved[3]; 
		DWORD dwReserved[4]; 
		BYTE bBuffer[1]; 
} SENDCMDINPARAMS,*PSENDCMDINPARAMS,*LPSENDCMDINPARAMS;
#include <poppack.h>
#include <pshpack1.h>
typedef struct _DRIVERSTATUS {
		BYTE bDriverError; 
		BYTE bIDEError; 
		BYTE bReserved[2]; 
		DWORD dwReserved[2]; 
} DRIVERSTATUS,*PDRIVERSTATUS,*LPDRIVERSTATUS;
#include <poppack.h>
#define SMART_NO_ERROR 0 
#define SMART_IDE_ERROR 1 
#define SMART_INVALID_FLAG 2 
#define SMART_INVALID_COMMAND 3 
#define SMART_INVALID_BUFFER 4 
#define SMART_INVALID_DRIVE 5 
#define SMART_INVALID_IOCTL 6 
#define SMART_ERROR_NO_MEM 7 
#define SMART_INVALID_REGISTER 8 
#define SMART_NOT_SUPPORTED 9 
#define SMART_NO_IDE_DEVICE 10 
#define SMART_OFFLINE_ROUTINE_OFFLINE 0
#define SMART_SHORT_SELFTEST_OFFLINE 1
#define SMART_EXTENDED_SELFTEST_OFFLINE 2
#define SMART_ABORT_OFFLINE_SELFTEST 127
#define SMART_SHORT_SELFTEST_CAPTIVE 129
#define SMART_EXTENDED_SELFTEST_CAPTIVE 130
#include <pshpack1.h>
typedef struct _SENDCMDOUTPARAMS {
		DWORD cBufferSize; 
		DRIVERSTATUS DriverStatus; 
		BYTE bBuffer[1]; 
} SENDCMDOUTPARAMS,*PSENDCMDOUTPARAMS,*LPSENDCMDOUTPARAMS;
#include <poppack.h>
#define READ_ATTRIBUTE_BUFFER_SIZE 512
#define IDENTIFY_BUFFER_SIZE 512
#define READ_THRESHOLD_BUFFER_SIZE 512
#define SMART_LOG_SECTOR_SIZE 512
#define READ_ATTRIBUTES 208
#define READ_THRESHOLDS 209
#define ENABLE_DISABLE_AUTOSAVE 210
#define SAVE_ATTRIBUTE_VALUES 211
#define EXECUTE_OFFLINE_DIAGS 212
#define SMART_READ_LOG 213
#define SMART_WRITE_LOG 214
#define ENABLE_SMART 216
#define DISABLE_SMART 217
#define RETURN_SMART_STATUS 218
#define ENABLE_DISABLE_AUTO_OFFLINE 219
#endif 
#define IOCTL_CHANGER_BASE FILE_DEVICE_CHANGER
#define IOCTL_CHANGER_GET_PARAMETERS CTL_CODE(IOCTL_CHANGER_BASE,0x0000,METHOD_BUFFERED,FILE_READ_ACCESS)
#define IOCTL_CHANGER_GET_STATUS CTL_CODE(IOCTL_CHANGER_BASE,0x0001,METHOD_BUFFERED,FILE_READ_ACCESS)
#define IOCTL_CHANGER_GET_PRODUCT_DATA CTL_CODE(IOCTL_CHANGER_BASE,0x0002,METHOD_BUFFERED,FILE_READ_ACCESS)
#define IOCTL_CHANGER_SET_ACCESS CTL_CODE(IOCTL_CHANGER_BASE,0x0004,METHOD_BUFFERED,FILE_READ_ACCESS|FILE_WRITE_ACCESS)
#define IOCTL_CHANGER_GET_ELEMENT_STATUS CTL_CODE(IOCTL_CHANGER_BASE,0x0005,METHOD_BUFFERED,FILE_READ_ACCESS|FILE_WRITE_ACCESS)
#define IOCTL_CHANGER_INITIALIZE_ELEMENT_STATUS CTL_CODE(IOCTL_CHANGER_BASE,0x0006,METHOD_BUFFERED,FILE_READ_ACCESS)
#define IOCTL_CHANGER_SET_POSITION CTL_CODE(IOCTL_CHANGER_BASE,0x0007,METHOD_BUFFERED,FILE_READ_ACCESS)
#define IOCTL_CHANGER_EXCHANGE_MEDIUM CTL_CODE(IOCTL_CHANGER_BASE,0x0008,METHOD_BUFFERED,FILE_READ_ACCESS)
#define IOCTL_CHANGER_MOVE_MEDIUM CTL_CODE(IOCTL_CHANGER_BASE,0x0009,METHOD_BUFFERED,FILE_READ_ACCESS)
#define IOCTL_CHANGER_REINITIALIZE_TRANSPORT CTL_CODE(IOCTL_CHANGER_BASE,0x000A,METHOD_BUFFERED,FILE_READ_ACCESS)
#define IOCTL_CHANGER_QUERY_VOLUME_TAGS CTL_CODE(IOCTL_CHANGER_BASE,0x000B,METHOD_BUFFERED,FILE_READ_ACCESS|FILE_WRITE_ACCESS)
#define MAX_VOLUME_ID_SIZE 36
#define MAX_VOLUME_TEMPLATE_SIZE 40
#define VENDOR_ID_LENGTH 8
#define PRODUCT_ID_LENGTH 16
#define REVISION_LENGTH 4
#define SERIAL_NUMBER_LENGTH 32
typedef enum _ELEMENT_TYPE {
	AllElements,ChangerTransport,ChangerSlot,ChangerIEPort,ChangerDrive,ChangerDoor,ChangerKeypad,ChangerMaxElement 
} ELEMENT_TYPE,*PELEMENT_TYPE;
typedef struct _CHANGER_ELEMENT {
	ELEMENT_TYPE ElementType;
	DWORD ElementAddress;
} CHANGER_ELEMENT,*PCHANGER_ELEMENT;
typedef struct _CHANGER_ELEMENT_LIST {
	CHANGER_ELEMENT Element;
	DWORD NumberOfElements;
} CHANGER_ELEMENT_LIST,*PCHANGER_ELEMENT_LIST;
#define CHANGER_BAR_CODE_SCANNER_INSTALLED 1 
#define CHANGER_INIT_ELEM_STAT_WITH_RANGE 2 
#define CHANGER_CLOSE_IEPORT 4 
#define CHANGER_OPEN_IEPORT 8 
#define CHANGER_STATUS_NON_VOLATILE 16 
#define CHANGER_EXCHANGE_MEDIA 32 
#define CHANGER_CLEANER_SLOT 64 
#define CHANGER_LOCK_UNLOCK 128 
#define CHANGER_CARTRIDGE_MAGAZINE 256 
#define CHANGER_MEDIUM_FLIP 512 
#define CHANGER_POSITION_TO_ELEMENT 1024 
#define CHANGER_REPORT_IEPORT_STATE 2048 
#define CHANGER_STORAGE_DRIVE 0x1000 
#define CHANGER_STORAGE_IEPORT 0x2000 
#define CHANGER_STORAGE_SLOT 0x4000 
#define CHANGER_STORAGE_TRANSPORT 0x8000 
#define CHANGER_DRIVE_CLEANING_REQUIRED 0x10000 
#define CHANGER_PREDISMOUNT_EJECT_REQUIRED 0x20000 
#define CHANGER_CLEANER_ACCESS_NOT_VALID 0x40000 
#define CHANGER_PREMOUNT_EJECT_REQUIRED 0x80000 
#define CHANGER_VOLUME_IDENTIFICATION 0x100000 
#define CHANGER_VOLUME_SEARCH 0x200000 
#define CHANGER_VOLUME_ASSERT 0x400000 
#define CHANGER_VOLUME_REPLACE 0x800000 
#define CHANGER_VOLUME_UNDEFINE 0x1000000 
#define CHANGER_SERIAL_NUMBER_VALID 0x4000000 
#define CHANGER_DEVICE_REINITIALIZE_CAPABLE 0x8000000 
#define CHANGER_KEYPAD_ENABLE_DISABLE 0x10000000 
#define CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS 0x20000000 
#define CHANGER_RESERVED_BIT 0x80000000 
#define CHANGER_PREDISMOUNT_ALIGN_TO_SLOT 0x80000001 
#define CHANGER_PREDISMOUNT_ALIGN_TO_DRIVE 0x80000002 
#define CHANGER_CLEANER_AUTODISMOUNT 0x80000004 
#define CHANGER_TRUE_EXCHANGE_CAPABLE 0x80000008 
#define CHANGER_SLOTS_USE_TRAYS 0x80000010 
#define CHANGER_RTN_MEDIA_TO_ORIGINAL_ADDR 0x80000020 
#define CHANGER_CLEANER_OPS_NOT_SUPPORTED 0x80000040 
#define CHANGER_IEPORT_USER_CONTROL_OPEN 0x80000080 
#define CHANGER_IEPORT_USER_CONTROL_CLOSE 0x80000100 
#define CHANGER_MOVE_EXTENDS_IEPORT 0x80000200 
#define CHANGER_MOVE_RETRACTS_IEPORT 0x80000400 
#define CHANGER_TO_TRANSPORT 1 
#define CHANGER_TO_SLOT 2 
#define CHANGER_TO_IEPORT 4 
#define CHANGER_TO_DRIVE 8 
#define LOCK_UNLOCK_IEPORT 1 
#define LOCK_UNLOCK_DOOR 2 
#define LOCK_UNLOCK_KEYPAD 4 
typedef struct _GET_CHANGER_PARAMETERS {
	DWORD Size;
	WORD NumberTransportElements;
	WORD NumberStorageElements; 
	WORD NumberCleanerSlots; 
	WORD NumberIEElements;
	WORD NumberDataTransferElements;
	WORD NumberOfDoors;
	WORD FirstSlotNumber;
	WORD FirstDriveNumber;
	WORD FirstTransportNumber;
	WORD FirstIEPortNumber;
	WORD FirstCleanerSlotAddress;
	WORD MagazineSize;
	DWORD DriveCleanTimeout;
	DWORD Features0;
	DWORD Features1;
	BYTE MoveFromTransport;
	BYTE MoveFromSlot;
	BYTE MoveFromIePort;
	BYTE MoveFromDrive;
	BYTE ExchangeFromTransport;
	BYTE ExchangeFromSlot;
	BYTE ExchangeFromIePort;
	BYTE ExchangeFromDrive;
	BYTE LockUnlockCapabilities;
	BYTE PositionCapabilities;
	BYTE Reserved1[2];
	DWORD Reserved2[2];
} GET_CHANGER_PARAMETERS,* PGET_CHANGER_PARAMETERS;
typedef struct _CHANGER_PRODUCT_DATA {
	BYTE VendorId[VENDOR_ID_LENGTH];
	BYTE ProductId[PRODUCT_ID_LENGTH];
	BYTE Revision[REVISION_LENGTH];
	BYTE SerialNumber[SERIAL_NUMBER_LENGTH];
	BYTE DeviceType;
} CHANGER_PRODUCT_DATA,*PCHANGER_PRODUCT_DATA;
#define LOCK_ELEMENT 0
#define UNLOCK_ELEMENT 1
#define EXTEND_IEPORT 2
#define RETRACT_IEPORT 3
typedef struct _CHANGER_SET_ACCESS {
	CHANGER_ELEMENT Element;
	DWORD Control;
} CHANGER_SET_ACCESS,*PCHANGER_SET_ACCESS;
typedef struct _CHANGER_READ_ELEMENT_STATUS {
	CHANGER_ELEMENT_LIST ElementList;
	BOOLEAN VolumeTagInfo;
} CHANGER_READ_ELEMENT_STATUS,*PCHANGER_READ_ELEMENT_STATUS;
typedef struct _CHANGER_ELEMENT_STATUS {
	CHANGER_ELEMENT Element;
	CHANGER_ELEMENT SrcElementAddress;
	DWORD Flags;
	DWORD ExceptionCode;
	BYTE TargetId;
	BYTE Lun;
	WORD Reserved;
	BYTE PrimaryVolumeID[MAX_VOLUME_ID_SIZE];
	BYTE AlternateVolumeID[MAX_VOLUME_ID_SIZE];
} CHANGER_ELEMENT_STATUS,*PCHANGER_ELEMENT_STATUS;
typedef struct _CHANGER_ELEMENT_STATUS_EX {
	CHANGER_ELEMENT Element;
	CHANGER_ELEMENT SrcElementAddress;
	DWORD Flags;
	DWORD ExceptionCode;
	BYTE TargetId;
	BYTE Lun;
	WORD Reserved;
	BYTE PrimaryVolumeID[MAX_VOLUME_ID_SIZE];
	BYTE AlternateVolumeID[MAX_VOLUME_ID_SIZE];
	BYTE VendorIdentification[VENDOR_ID_LENGTH];
	BYTE ProductIdentification[PRODUCT_ID_LENGTH];
	BYTE SerialNumber[SERIAL_NUMBER_LENGTH];
} CHANGER_ELEMENT_STATUS_EX,*PCHANGER_ELEMENT_STATUS_EX;
#define ELEMENT_STATUS_FULL 1 
#define ELEMENT_STATUS_IMPEXP 2 
#define ELEMENT_STATUS_EXCEPT 4 
#define ELEMENT_STATUS_ACCESS 8 
#define ELEMENT_STATUS_EXENAB 16 
#define ELEMENT_STATUS_INENAB 32 
#define ELEMENT_STATUS_PRODUCT_DATA 64 
#define ELEMENT_STATUS_LUN_VALID 0x1000 
#define ELEMENT_STATUS_ID_VALID 0x2000 
#define ELEMENT_STATUS_NOT_BUS 0x8000 
#define ELEMENT_STATUS_INVERT 0x400000 
#define ELEMENT_STATUS_SVALID 0x800000 
#define ELEMENT_STATUS_PVOLTAG 0x10000000 
#define ELEMENT_STATUS_AVOLTAG 0x20000000 
#define ERROR_LABEL_UNREADABLE 1 
#define ERROR_LABEL_QUESTIONABLE 2 
#define ERROR_SLOT_NOT_PRESENT 4 
#define ERROR_DRIVE_NOT_INSTALLED 8 
#define ERROR_TRAY_MALFUNCTION 16 
#define ERROR_INIT_STATUS_NEEDED 17 
#define ERROR_UNHANDLED_ERROR 0xffffffff 
typedef struct _CHANGER_INITIALIZE_ELEMENT_STATUS {
	CHANGER_ELEMENT_LIST ElementList;
	BOOLEAN BarCodeScan;
} CHANGER_INITIALIZE_ELEMENT_STATUS,*PCHANGER_INITIALIZE_ELEMENT_STATUS;
typedef struct _CHANGER_SET_POSITION {
	CHANGER_ELEMENT Transport;
	CHANGER_ELEMENT Destination;
	BOOLEAN Flip;
} CHANGER_SET_POSITION,*PCHANGER_SET_POSITION;
typedef struct _CHANGER_EXCHANGE_MEDIUM {
	CHANGER_ELEMENT Transport;
	CHANGER_ELEMENT Source;
	CHANGER_ELEMENT Destination1;
	CHANGER_ELEMENT Destination2;
	BOOLEAN Flip1;
	BOOLEAN Flip2;
} CHANGER_EXCHANGE_MEDIUM,*PCHANGER_EXCHANGE_MEDIUM;
typedef struct _CHANGER_MOVE_MEDIUM {
	CHANGER_ELEMENT Transport;
	CHANGER_ELEMENT Source;
	CHANGER_ELEMENT Destination;
	BOOLEAN Flip;
} CHANGER_MOVE_MEDIUM,*PCHANGER_MOVE_MEDIUM;
typedef struct _CHANGER_SEND_VOLUME_TAG_INFORMATION {
	CHANGER_ELEMENT StartingElement;
	DWORD ActionCode;
	BYTE VolumeIDTemplate[MAX_VOLUME_TEMPLATE_SIZE];
} CHANGER_SEND_VOLUME_TAG_INFORMATION,*PCHANGER_SEND_VOLUME_TAG_INFORMATION;
typedef struct _READ_ELEMENT_ADDRESS_INFO {
	DWORD NumberOfElements;
	CHANGER_ELEMENT_STATUS ElementStatus[1];
} READ_ELEMENT_ADDRESS_INFO,*PREAD_ELEMENT_ADDRESS_INFO;
#define SEARCH_ALL 0 
#define SEARCH_PRIMARY 1 
#define SEARCH_ALTERNATE 2 
#define SEARCH_ALL_NO_SEQ 4 
#define SEARCH_PRI_NO_SEQ 5 
#define SEARCH_ALT_NO_SEQ 6 
#define ASSERT_PRIMARY 8 
#define ASSERT_ALTERNATE 9 
#define REPLACE_PRIMARY 10 
#define REPLACE_ALTERNATE 11 
#define UNDEFINE_PRIMARY 12 
#define UNDEFINE_ALTERNATE 13 
typedef enum _CHANGER_DEVICE_PROBLEM_TYPE {
	DeviceProblemNone,DeviceProblemHardware,DeviceProblemCHMError,DeviceProblemDoorOpen,DeviceProblemCalibrationError,
	DeviceProblemTargetFailure,DeviceProblemCHMMoveError,DeviceProblemCHMZeroError,DeviceProblemCartridgeInsertError,
	DeviceProblemPositionError, DeviceProblemSensorError,DeviceProblemCartridgeEjectError,DeviceProblemGripperError,DeviceProblemDriveError
} CHANGER_DEVICE_PROBLEM_TYPE,*PCHANGER_DEVICE_PROBLEM_TYPE;
#define IOCTL_SERIAL_LSRMST_INSERT CTL_CODE(FILE_DEVICE_SERIAL_PORT,31,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERENUM_EXPOSE_HARDWARE CTL_CODE(FILE_DEVICE_SERENUM,128,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERENUM_REMOVE_HARDWARE CTL_CODE(FILE_DEVICE_SERENUM,129,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERENUM_PORT_DESC CTL_CODE(FILE_DEVICE_SERENUM,130,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERENUM_GET_PORT_NAME CTL_CODE(FILE_DEVICE_SERENUM,131,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define SERIAL_LSRMST_ESCAPE ((BYTE )0x00)
#define SERIAL_LSRMST_LSR_DATA ((BYTE )0x01)
#define SERIAL_LSRMST_LSR_NODATA ((BYTE )0x02)
#define SERIAL_LSRMST_MST ((BYTE )0x03)
#define SERIAL_IOC_FCR_FIFO_ENABLE ((DWORD)0x00000001)
#define SERIAL_IOC_FCR_RCVR_RESET ((DWORD)0x00000002)
#define SERIAL_IOC_FCR_XMIT_RESET ((DWORD)0x00000004)
#define SERIAL_IOC_FCR_DMA_MODE ((DWORD)0x00000008)
#define SERIAL_IOC_FCR_RES1 ((DWORD)0x00000010)
#define SERIAL_IOC_FCR_RES2 ((DWORD)0x00000020)
#define SERIAL_IOC_FCR_RCVR_TRIGGER_LSB ((DWORD)0x00000040)
#define SERIAL_IOC_FCR_RCVR_TRIGGER_MSB ((DWORD)0x00000080)
#define SERIAL_IOC_MCR_DTR ((DWORD)0x00000001)
#define SERIAL_IOC_MCR_RTS ((DWORD)0x00000002)
#define SERIAL_IOC_MCR_OUT1 ((DWORD)0x00000004)
#define SERIAL_IOC_MCR_OUT2 ((DWORD)0x00000008)
#define SERIAL_IOC_MCR_LOOP ((DWORD)0x00000010)
#ifndef _FILESYSTEMFSCTL_
#define _FILESYSTEMFSCTL_
#define FSCTL_REQUEST_OPLOCK_LEVEL_1 CTL_CODE(FILE_DEVICE_FILE_SYSTEM,0,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define FSCTL_REQUEST_OPLOCK_LEVEL_2 CTL_CODE(FILE_DEVICE_FILE_SYSTEM,1,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define FSCTL_REQUEST_BATCH_OPLOCK CTL_CODE(FILE_DEVICE_FILE_SYSTEM,2,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define FSCTL_OPLOCK_BREAK_ACKNOWLEDGE CTL_CODE(FILE_DEVICE_FILE_SYSTEM,3,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define FSCTL_OPBATCH_ACK_CLOSE_PENDING CTL_CODE(FILE_DEVICE_FILE_SYSTEM,4,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define FSCTL_OPLOCK_BREAK_NOTIFY CTL_CODE(FILE_DEVICE_FILE_SYSTEM,5,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define FSCTL_LOCK_VOLUME CTL_CODE(FILE_DEVICE_FILE_SYSTEM,6,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define FSCTL_UNLOCK_VOLUME CTL_CODE(FILE_DEVICE_FILE_SYSTEM,7,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define FSCTL_DISMOUNT_VOLUME CTL_CODE(FILE_DEVICE_FILE_SYSTEM,8,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define FSCTL_IS_VOLUME_MOUNTED CTL_CODE(FILE_DEVICE_FILE_SYSTEM,10,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define FSCTL_IS_PATHNAME_VALID CTL_CODE(FILE_DEVICE_FILE_SYSTEM,11,METHOD_BUFFERED,FILE_ANY_ACCESS) 
#define FSCTL_MARK_VOLUME_DIRTY CTL_CODE(FILE_DEVICE_FILE_SYSTEM,12,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define FSCTL_QUERY_RETRIEVAL_POINTERS CTL_CODE(FILE_DEVICE_FILE_SYSTEM,14,METHOD_NEITHER,FILE_ANY_ACCESS)
#define FSCTL_GET_COMPRESSION CTL_CODE(FILE_DEVICE_FILE_SYSTEM,15,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define FSCTL_SET_COMPRESSION CTL_CODE(FILE_DEVICE_FILE_SYSTEM,16,METHOD_BUFFERED,FILE_READ_DATA|FILE_WRITE_DATA)
#define FSCTL_MARK_AS_SYSTEM_HIVE CTL_CODE(FILE_DEVICE_FILE_SYSTEM,19,METHOD_NEITHER,FILE_ANY_ACCESS)
#define FSCTL_OPLOCK_BREAK_ACK_NO_2 CTL_CODE(FILE_DEVICE_FILE_SYSTEM,20,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define FSCTL_INVALIDATE_VOLUMES CTL_CODE(FILE_DEVICE_FILE_SYSTEM,21,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define FSCTL_QUERY_FAT_BPB CTL_CODE(FILE_DEVICE_FILE_SYSTEM,22,METHOD_BUFFERED,FILE_ANY_ACCESS) 
#define FSCTL_REQUEST_FILTER_OPLOCK CTL_CODE(FILE_DEVICE_FILE_SYSTEM,23,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define FSCTL_FILESYSTEM_GET_STATISTICS CTL_CODE(FILE_DEVICE_FILE_SYSTEM,24,METHOD_BUFFERED,FILE_ANY_ACCESS) 
#if(_WIN32_WINNT >=0x0400)
#define FSCTL_GET_NTFS_VOLUME_DATA CTL_CODE(FILE_DEVICE_FILE_SYSTEM,25,METHOD_BUFFERED,FILE_ANY_ACCESS) 
#define FSCTL_GET_NTFS_FILE_RECORD CTL_CODE(FILE_DEVICE_FILE_SYSTEM,26,METHOD_BUFFERED,FILE_ANY_ACCESS) 
#define FSCTL_GET_VOLUME_BITMAP CTL_CODE(FILE_DEVICE_FILE_SYSTEM,27,METHOD_NEITHER,FILE_ANY_ACCESS) 
#define FSCTL_GET_RETRIEVAL_POINTERS CTL_CODE(FILE_DEVICE_FILE_SYSTEM,28,METHOD_NEITHER,FILE_ANY_ACCESS) 
#define FSCTL_MOVE_FILE CTL_CODE(FILE_DEVICE_FILE_SYSTEM,29,METHOD_BUFFERED,FILE_SPECIAL_ACCESS) 
#define FSCTL_IS_VOLUME_DIRTY CTL_CODE(FILE_DEVICE_FILE_SYSTEM,30,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define FSCTL_ALLOW_EXTENDED_DASD_IO CTL_CODE(FILE_DEVICE_FILE_SYSTEM,32,METHOD_NEITHER,FILE_ANY_ACCESS)
#endif 
#if(_WIN32_WINNT >=0x0500)
#define FSCTL_FIND_FILES_BY_SID CTL_CODE(FILE_DEVICE_FILE_SYSTEM,35,METHOD_NEITHER,FILE_ANY_ACCESS) 
#define FSCTL_SET_OBJECT_ID CTL_CODE(FILE_DEVICE_FILE_SYSTEM,38,METHOD_BUFFERED,FILE_SPECIAL_ACCESS) 
#define FSCTL_GET_OBJECT_ID CTL_CODE(FILE_DEVICE_FILE_SYSTEM,39,METHOD_BUFFERED,FILE_ANY_ACCESS) 
#define FSCTL_DELETE_OBJECT_ID CTL_CODE(FILE_DEVICE_FILE_SYSTEM,40,METHOD_BUFFERED,FILE_SPECIAL_ACCESS)
#define FSCTL_SET_REPARSE_POINT CTL_CODE(FILE_DEVICE_FILE_SYSTEM,41,METHOD_BUFFERED,FILE_SPECIAL_ACCESS) 
#define FSCTL_GET_REPARSE_POINT CTL_CODE(FILE_DEVICE_FILE_SYSTEM,42,METHOD_BUFFERED,FILE_ANY_ACCESS) 
#define FSCTL_DELETE_REPARSE_POINT CTL_CODE(FILE_DEVICE_FILE_SYSTEM,43,METHOD_BUFFERED,FILE_SPECIAL_ACCESS) 
#define FSCTL_ENUM_USN_DATA CTL_CODE(FILE_DEVICE_FILE_SYSTEM,44,METHOD_NEITHER,FILE_ANY_ACCESS) 
#define FSCTL_SECURITY_ID_CHECK CTL_CODE(FILE_DEVICE_FILE_SYSTEM,45,METHOD_NEITHER,FILE_READ_DATA) 
#define FSCTL_READ_USN_JOURNAL CTL_CODE(FILE_DEVICE_FILE_SYSTEM,46,METHOD_NEITHER,FILE_ANY_ACCESS) 
#define FSCTL_SET_OBJECT_ID_EXTENDED CTL_CODE(FILE_DEVICE_FILE_SYSTEM,47,METHOD_BUFFERED,FILE_SPECIAL_ACCESS)
#define FSCTL_CREATE_OR_GET_OBJECT_ID CTL_CODE(FILE_DEVICE_FILE_SYSTEM,48,METHOD_BUFFERED,FILE_ANY_ACCESS) 
#define FSCTL_SET_SPARSE CTL_CODE(FILE_DEVICE_FILE_SYSTEM,49,METHOD_BUFFERED,FILE_SPECIAL_ACCESS)
#define FSCTL_SET_ZERO_DATA CTL_CODE(FILE_DEVICE_FILE_SYSTEM,50,METHOD_BUFFERED,FILE_WRITE_DATA) 
#define FSCTL_QUERY_ALLOCATED_RANGES CTL_CODE(FILE_DEVICE_FILE_SYSTEM,51,METHOD_NEITHER,FILE_READ_DATA) 
#define FSCTL_SET_ENCRYPTION CTL_CODE(FILE_DEVICE_FILE_SYSTEM,53,METHOD_NEITHER,FILE_ANY_ACCESS) 
#define FSCTL_ENCRYPTION_FSCTL_IO CTL_CODE(FILE_DEVICE_FILE_SYSTEM,54,METHOD_NEITHER,FILE_ANY_ACCESS)
#define FSCTL_WRITE_RAW_ENCRYPTED CTL_CODE(FILE_DEVICE_FILE_SYSTEM,55,METHOD_NEITHER,FILE_SPECIAL_ACCESS) 
#define FSCTL_READ_RAW_ENCRYPTED CTL_CODE(FILE_DEVICE_FILE_SYSTEM,56,METHOD_NEITHER,FILE_SPECIAL_ACCESS) 
#define FSCTL_CREATE_USN_JOURNAL CTL_CODE(FILE_DEVICE_FILE_SYSTEM,57,METHOD_NEITHER,FILE_ANY_ACCESS) 
#define FSCTL_READ_FILE_USN_DATA CTL_CODE(FILE_DEVICE_FILE_SYSTEM,58,METHOD_NEITHER,FILE_ANY_ACCESS) 
#define FSCTL_WRITE_USN_CLOSE_RECORD CTL_CODE(FILE_DEVICE_FILE_SYSTEM,59,METHOD_NEITHER,FILE_ANY_ACCESS) 
#define FSCTL_EXTEND_VOLUME CTL_CODE(FILE_DEVICE_FILE_SYSTEM,60,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define FSCTL_QUERY_USN_JOURNAL CTL_CODE(FILE_DEVICE_FILE_SYSTEM,61,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define FSCTL_DELETE_USN_JOURNAL CTL_CODE(FILE_DEVICE_FILE_SYSTEM,62,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define FSCTL_MARK_HANDLE CTL_CODE(FILE_DEVICE_FILE_SYSTEM,63,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define FSCTL_SIS_COPYFILE CTL_CODE(FILE_DEVICE_FILE_SYSTEM,64,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define FSCTL_SIS_LINK_FILES CTL_CODE(FILE_DEVICE_FILE_SYSTEM,65,METHOD_BUFFERED,FILE_READ_DATA|FILE_WRITE_DATA)
#define FSCTL_HSM_MSG CTL_CODE(FILE_DEVICE_FILE_SYSTEM,66,METHOD_BUFFERED,FILE_READ_DATA|FILE_WRITE_DATA)
#define FSCTL_HSM_DATA CTL_CODE(FILE_DEVICE_FILE_SYSTEM,68,METHOD_NEITHER,FILE_READ_DATA|FILE_WRITE_DATA)
#define FSCTL_RECALL_FILE CTL_CODE(FILE_DEVICE_FILE_SYSTEM,69,METHOD_NEITHER,FILE_ANY_ACCESS)
#define FSCTL_READ_FROM_PLEX CTL_CODE(FILE_DEVICE_FILE_SYSTEM,71,METHOD_OUT_DIRECT,FILE_READ_DATA)
#define FSCTL_FILE_PREFETCH CTL_CODE(FILE_DEVICE_FILE_SYSTEM,72,METHOD_BUFFERED,FILE_SPECIAL_ACCESS) 
#endif 
typedef struct _PATHNAME_BUFFER {
	DWORD PathNameLength;
	WCHAR Name[1];
} PATHNAME_BUFFER,*PPATHNAME_BUFFER;
typedef struct _FSCTL_QUERY_FAT_BPB_BUFFER {
	BYTE First0x24BytesOfBootSector[0x24];
} FSCTL_QUERY_FAT_BPB_BUFFER,*PFSCTL_QUERY_FAT_BPB_BUFFER;
#if(_WIN32_WINNT >=0x0400)
typedef struct {
	LARGE_INTEGER VolumeSerialNumber;
	LARGE_INTEGER NumberSectors;
	LARGE_INTEGER TotalClusters;
	LARGE_INTEGER FreeClusters;
	LARGE_INTEGER TotalReserved;
	DWORD BytesPerSector;
	DWORD BytesPerCluster;
	DWORD BytesPerFileRecordSegment;
	DWORD ClustersPerFileRecordSegment;
	LARGE_INTEGER MftValidDataLength;
	LARGE_INTEGER MftStartLcn;
	LARGE_INTEGER Mft2StartLcn;
	LARGE_INTEGER MftZoneStart;
	LARGE_INTEGER MftZoneEnd;
} NTFS_VOLUME_DATA_BUFFER,*PNTFS_VOLUME_DATA_BUFFER;
typedef struct {
	DWORD ByteCount;
	WORD MajorVersion;
	WORD MinorVersion;
} NTFS_EXTENDED_VOLUME_DATA,*PNTFS_EXTENDED_VOLUME_DATA;
#endif 
#if(_WIN32_WINNT >=0x0400)
typedef struct {
	LARGE_INTEGER StartingLcn;
} STARTING_LCN_INPUT_BUFFER,*PSTARTING_LCN_INPUT_BUFFER;
typedef struct {
	LARGE_INTEGER StartingLcn;
	LARGE_INTEGER BitmapSize;
	BYTE Buffer[1];
} VOLUME_BITMAP_BUFFER,*PVOLUME_BITMAP_BUFFER;
#endif 
#if(_WIN32_WINNT >=0x0400)
typedef struct {
	LARGE_INTEGER StartingVcn;
} STARTING_VCN_INPUT_BUFFER,*PSTARTING_VCN_INPUT_BUFFER;
typedef struct RETRIEVAL_POINTERS_BUFFER {
	DWORD ExtentCount;
	LARGE_INTEGER StartingVcn;
	struct {
		LARGE_INTEGER NextVcn;
		LARGE_INTEGER Lcn;
	} Extents[1];
} RETRIEVAL_POINTERS_BUFFER,*PRETRIEVAL_POINTERS_BUFFER;
#endif 
#if(_WIN32_WINNT >=0x0400)
typedef struct {
	LARGE_INTEGER FileReferenceNumber;
} NTFS_FILE_RECORD_INPUT_BUFFER,*PNTFS_FILE_RECORD_INPUT_BUFFER;
typedef struct {
	LARGE_INTEGER FileReferenceNumber;
	DWORD FileRecordLength;
	BYTE FileRecordBuffer[1];
} NTFS_FILE_RECORD_OUTPUT_BUFFER,*PNTFS_FILE_RECORD_OUTPUT_BUFFER;
#endif 
#if(_WIN32_WINNT >=0x0400)
typedef struct {
	HANDLE FileHandle;
	LARGE_INTEGER StartingVcn;
	LARGE_INTEGER StartingLcn;
	DWORD ClusterCount;
} MOVE_FILE_DATA,*PMOVE_FILE_DATA;
#if defined(_WIN64)
typedef struct _MOVE_FILE_DATA32 {
	UINT32 FileHandle;
	LARGE_INTEGER StartingVcn;
	LARGE_INTEGER StartingLcn;
	DWORD ClusterCount;
} MOVE_FILE_DATA32,*PMOVE_FILE_DATA32;
#endif
#endif 
#if(_WIN32_WINNT >=0x0500)
typedef struct {
	DWORD Restart;
	SID Sid;
} FIND_BY_SID_DATA,*PFIND_BY_SID_DATA;
typedef struct {
	DWORD NextEntryOffset;
	DWORD FileIndex;
	DWORD FileNameLength;
	WCHAR FileName[1];
} FIND_BY_SID_OUTPUT,*PFIND_BY_SID_OUTPUT;
#endif 
#if(_WIN32_WINNT >=0x0500)
typedef struct {
	DWORDLONG StartFileReferenceNumber;
	USN LowUsn;
	USN HighUsn;
} MFT_ENUM_DATA,*PMFT_ENUM_DATA;
typedef struct {
	DWORDLONG MaximumSize;
	DWORDLONG AllocationDelta;
} CREATE_USN_JOURNAL_DATA,*PCREATE_USN_JOURNAL_DATA;
typedef struct {
	USN StartUsn;
	DWORD ReasonMask;
	DWORD ReturnOnlyOnClose;
	DWORDLONG Timeout;
	DWORDLONG BytesToWaitFor;
	DWORDLONG UsnJournalID;
} READ_USN_JOURNAL_DATA,*PREAD_USN_JOURNAL_DATA;
typedef struct {
	DWORD RecordLength;
	WORD MajorVersion;
	WORD MinorVersion;
	DWORDLONG FileReferenceNumber;
	DWORDLONG ParentFileReferenceNumber;
	USN Usn;
	LARGE_INTEGER TimeStamp;
	DWORD Reason;
	DWORD SourceInfo;
	DWORD SecurityId;
	DWORD FileAttributes;
	WORD FileNameLength;
	WORD FileNameOffset;
	WCHAR FileName[1];
} USN_RECORD,*PUSN_RECORD;
#define USN_PAGE_SIZE 0x1000
#define USN_REASON_DATA_OVERWRITE 1
#define USN_REASON_DATA_EXTEND 2
#define USN_REASON_DATA_TRUNCATION 4
#define USN_REASON_NAMED_DATA_OVERWRITE 16
#define USN_REASON_NAMED_DATA_EXTEND 32
#define USN_REASON_NAMED_DATA_TRUNCATION 64
#define USN_REASON_FILE_CREATE 256
#define USN_REASON_FILE_DELETE 512
#define USN_REASON_EA_CHANGE 1024
#define USN_REASON_SECURITY_CHANGE 2048
#define USN_REASON_RENAME_OLD_NAME 0x1000
#define USN_REASON_RENAME_NEW_NAME 0x2000
#define USN_REASON_INDEXABLE_CHANGE 0x4000
#define USN_REASON_BASIC_INFO_CHANGE 0x8000
#define USN_REASON_HARD_LINK_CHANGE 0x10000
#define USN_REASON_COMPRESSION_CHANGE 0x20000
#define USN_REASON_ENCRYPTION_CHANGE 0x40000
#define USN_REASON_OBJECT_ID_CHANGE 0x80000
#define USN_REASON_REPARSE_POINT_CHANGE 0x100000
#define USN_REASON_STREAM_CHANGE 0x200000
#define USN_REASON_CLOSE 0x80000000
typedef struct {
	DWORDLONG UsnJournalID;
	USN FirstUsn;
	USN NextUsn;
	USN LowestValidUsn;
	USN MaxUsn;
	DWORDLONG MaximumSize;
	DWORDLONG AllocationDelta;
} USN_JOURNAL_DATA,*PUSN_JOURNAL_DATA;
typedef struct {
	DWORDLONG UsnJournalID;
	DWORD DeleteFlags;
} DELETE_USN_JOURNAL_DATA,*PDELETE_USN_JOURNAL_DATA;
#define USN_DELETE_FLAG_DELETE 1
#define USN_DELETE_FLAG_NOTIFY 2
#define USN_DELETE_VALID_FLAGS 3
typedef struct {
	DWORD UsnSourceInfo;
	HANDLE VolumeHandle;
	DWORD HandleInfo;
} MARK_HANDLE_INFO,*PMARK_HANDLE_INFO;
#if defined(_WIN64)
typedef struct {
	DWORD UsnSourceInfo;
	UINT32 VolumeHandle;
	DWORD HandleInfo;
} MARK_HANDLE_INFO32,*PMARK_HANDLE_INFO32;
#endif
#define USN_SOURCE_DATA_MANAGEMENT 1
#define USN_SOURCE_AUXILIARY_DATA 2
#define USN_SOURCE_REPLICATION_MANAGEMENT 4
#define MARK_HANDLE_PROTECT_CLUSTERS 1
#endif 
#if(_WIN32_WINNT >=0x0500)
typedef struct {
	ACCESS_MASK DesiredAccess;
	DWORD SecurityIds[1];
} BULK_SECURITY_TEST_DATA,*PBULK_SECURITY_TEST_DATA;
#endif 
#if(_WIN32_WINNT >=0x0500)
#define VOLUME_IS_DIRTY 1
#define VOLUME_UPGRADE_SCHEDULED 2
#endif 
typedef struct _FILE_PREFETCH {
	DWORD Type;
	DWORD Count;
	DWORDLONG Prefetch[1];
} FILE_PREFETCH,*PFILE_PREFETCH;
#define FILE_PREFETCH_TYPE_FOR_CREATE 1
typedef struct _FILESYSTEM_STATISTICS {
	WORD FileSystemType;
	WORD Version; 
	DWORD SizeOfCompleteStructure; 
	DWORD UserFileReads;
	DWORD UserFileReadBytes;
	DWORD UserDiskReads;
	DWORD UserFileWrites;
	DWORD UserFileWriteBytes;
	DWORD UserDiskWrites;
	DWORD MetaDataReads;
	DWORD MetaDataReadBytes;
	DWORD MetaDataDiskReads;
	DWORD MetaDataWrites;
	DWORD MetaDataWriteBytes;
	DWORD MetaDataDiskWrites;
} FILESYSTEM_STATISTICS,*PFILESYSTEM_STATISTICS;
#define FILESYSTEM_STATISTICS_TYPE_NTFS 1
#define FILESYSTEM_STATISTICS_TYPE_FAT 2
typedef struct _FAT_STATISTICS {
	DWORD CreateHits;
	DWORD SuccessfulCreates;
	DWORD FailedCreates;
	DWORD NonCachedReads;
	DWORD NonCachedReadBytes;
	DWORD NonCachedWrites;
	DWORD NonCachedWriteBytes;
	DWORD NonCachedDiskReads;
	DWORD NonCachedDiskWrites;
} FAT_STATISTICS,*PFAT_STATISTICS;
typedef struct _NTFS_STATISTICS {
	DWORD LogFileFullExceptions;
	DWORD OtherExceptions;
	DWORD MftReads;
	DWORD MftReadBytes;
	DWORD MftWrites;
	DWORD MftWriteBytes;
	struct {
		WORD Write;
		WORD Create;
		WORD SetInfo;
		WORD Flush;
	} MftWritesUserLevel;
	WORD MftWritesFlushForLogFileFull;
	WORD MftWritesLazyWriter;
	WORD MftWritesUserRequest;
	DWORD Mft2Writes;
	DWORD Mft2WriteBytes;
	struct {
		WORD Write;
		WORD Create;
		WORD SetInfo;
		WORD Flush;
	} Mft2WritesUserLevel;
	WORD Mft2WritesFlushForLogFileFull;
	WORD Mft2WritesLazyWriter;
	WORD Mft2WritesUserRequest;
	DWORD RootIndexReads;
	DWORD RootIndexReadBytes;
	DWORD RootIndexWrites;
	DWORD RootIndexWriteBytes;
	DWORD BitmapReads;
	DWORD BitmapReadBytes;
	DWORD BitmapWrites;
	DWORD BitmapWriteBytes;
	WORD BitmapWritesFlushForLogFileFull;
	WORD BitmapWritesLazyWriter;
	WORD BitmapWritesUserRequest;
	struct {
		WORD Write;
		WORD Create;
		WORD SetInfo;
	} BitmapWritesUserLevel;
	DWORD MftBitmapReads;
	DWORD MftBitmapReadBytes;
	DWORD MftBitmapWrites;
	DWORD MftBitmapWriteBytes;
	WORD MftBitmapWritesFlushForLogFileFull;
	WORD MftBitmapWritesLazyWriter;
	WORD MftBitmapWritesUserRequest;
	struct {
		WORD Write;
		WORD Create;
		WORD SetInfo;
		WORD Flush;
	} MftBitmapWritesUserLevel;
	DWORD UserIndexReads;
	DWORD UserIndexReadBytes;
	DWORD UserIndexWrites;
	DWORD UserIndexWriteBytes;
	DWORD LogFileReads;
	DWORD LogFileReadBytes;
	DWORD LogFileWrites;
	DWORD LogFileWriteBytes;
	struct {
		DWORD Calls; 
		DWORD Clusters; 
		DWORD Hints; 
		DWORD RunsReturned; 
		DWORD HintsHonored; 
		DWORD HintsClusters; 
		DWORD Cache; 
		DWORD CacheClusters; 
		DWORD CacheMiss; 
		DWORD CacheMissClusters; 
	} Allocate;
} NTFS_STATISTICS,*PNTFS_STATISTICS;
#if(_WIN32_WINNT >=0x0500)
#if _MSC_VER >=1200
#pragma warning(push)
#endif
#pragma warning(disable:4201) 
typedef struct _FILE_OBJECTID_BUFFER {
	BYTE ObjectId[16];
	union {
		struct {
			BYTE BirthVolumeId[16];
			BYTE BirthObjectId[16];
			BYTE DomainId[16];
		} ;
		BYTE ExtendedInfo[48];
	};
} FILE_OBJECTID_BUFFER,*PFILE_OBJECTID_BUFFER;
#if _MSC_VER >=1200
#pragma warning(pop)
#else
#pragma warning(default : 4201 )
#endif
#endif 
#if(_WIN32_WINNT >=0x0500)
typedef struct _FILE_SET_SPARSE_BUFFER {
	BOOLEAN SetSparse;
} FILE_SET_SPARSE_BUFFER,*PFILE_SET_SPARSE_BUFFER;
#endif 
#if(_WIN32_WINNT >=0x0500)
typedef struct _FILE_ZERO_DATA_INFORMATION {
	LARGE_INTEGER FileOffset;
	LARGE_INTEGER BeyondFinalZero;
} FILE_ZERO_DATA_INFORMATION,*PFILE_ZERO_DATA_INFORMATION;
#endif 
#if(_WIN32_WINNT >=0x0500)
typedef struct _FILE_ALLOCATED_RANGE_BUFFER {
	LARGE_INTEGER FileOffset;
	LARGE_INTEGER Length;
} FILE_ALLOCATED_RANGE_BUFFER,*PFILE_ALLOCATED_RANGE_BUFFER;
#endif 
#if(_WIN32_WINNT >=0x0500)
typedef struct _ENCRYPTION_BUFFER {
	DWORD EncryptionOperation;
	BYTE Private[1];
} ENCRYPTION_BUFFER,*PENCRYPTION_BUFFER;
#define FILE_SET_ENCRYPTION 1
#define FILE_CLEAR_ENCRYPTION 2
#define STREAM_SET_ENCRYPTION 3
#define STREAM_CLEAR_ENCRYPTION 4
#define MAXIMUM_ENCRYPTION_VALUE 4
typedef struct _DECRYPTION_STATUS_BUFFER {
	BOOLEAN NoEncryptedStreams;
} DECRYPTION_STATUS_BUFFER,*PDECRYPTION_STATUS_BUFFER;
#define ENCRYPTION_FORMAT_DEFAULT 1
#define COMPRESSION_FORMAT_SPARSE 0x4000
typedef struct _REQUEST_RAW_ENCRYPTED_DATA {
	LONGLONG FileOffset;
	DWORD Length;
} REQUEST_RAW_ENCRYPTED_DATA,*PREQUEST_RAW_ENCRYPTED_DATA;
typedef struct _ENCRYPTED_DATA_INFO {
	DWORDLONG StartingFileOffset;
	DWORD OutputBufferOffset;
	DWORD BytesWithinFileSize;
	DWORD BytesWithinValidDataLength;
	WORD CompressionFormat;
	BYTE DataUnitShift;
	BYTE ChunkShift;
	BYTE ClusterShift;
	BYTE EncryptionFormat;
	WORD NumberOfDataBlocks;
	DWORD DataBlockSize[ANYSIZE_ARRAY];
} ENCRYPTED_DATA_INFO;
typedef ENCRYPTED_DATA_INFO *PENCRYPTED_DATA_INFO;
#endif 
#if(_WIN32_WINNT >=0x0500)
typedef struct _PLEX_READ_DATA_REQUEST {
	LARGE_INTEGER ByteOffset;
	DWORD ByteLength;
	DWORD PlexNumber;
} PLEX_READ_DATA_REQUEST,*PPLEX_READ_DATA_REQUEST;
#endif 
#if(_WIN32_WINNT >=0x0500)
typedef struct _SI_COPYFILE {
	DWORD SourceFileNameLength;
	DWORD DestinationFileNameLength;
	DWORD Flags;
	WCHAR FileNameBuffer[1];
} SI_COPYFILE,*PSI_COPYFILE;
#define COPYFILE_SIS_LINK 1 
#define COPYFILE_SIS_REPLACE 2 
#define COPYFILE_SIS_FLAGS 3
#endif 
#endif 
#define IOCTL_VOLUME_BASE ((DWORD) 'V')
#define IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS CTL_CODE(IOCTL_VOLUME_BASE,0,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_VOLUME_IS_CLUSTERED CTL_CODE(IOCTL_VOLUME_BASE,12,METHOD_BUFFERED,FILE_ANY_ACCESS)
typedef struct _DISK_EXTENT {
	DWORD DiskNumber;
	LARGE_INTEGER StartingOffset;
	LARGE_INTEGER ExtentLength;
} DISK_EXTENT,*PDISK_EXTENT;
typedef struct _VOLUME_DISK_EXTENTS {
	DWORD NumberOfDiskExtents;
	DISK_EXTENT Extents[1];
} VOLUME_DISK_EXTENTS,*PVOLUME_DISK_EXTENTS;
#endif 

